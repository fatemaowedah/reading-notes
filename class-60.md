###  Application State with Redux
####  Redux Store
Managing state with Redux requires the combination of 3 distinct: State, Reducers: hold and manage state, typically manage just one part of the larger application state, Actions:are payloads of information that send data from your application to your store. They are the only source of information for the store, creator function returns an action object with the action type to perform and the data to perform it with. When your component wants to modify state, it calls an action and sends data to the reducer, store: where your application state, to identify the various reducers and middleware that need to be made available and used globally,use a store to bring  all  in the store, you declare what middleware you may need and the reducers that you’ll use to manage your state data, Before any of this can work, your entire application needs to be given access to the store. Your component uses the redux connect() method to attach to the store.
####  worlds easiest guide to redux
It helps you write applications that behave consistently, if you have a lot of data changing in your application over time, it give us the ability to  logging, hot reloading, time travel, universal apps, record and replay,The name and status rendered in the Header are those of the clicked user, Submitting the Form:add a handleSubmit use e.preventDefault()  The typing value and activeUserId are fetched from the state since they’ll both be used to create the dispatched action  action is dispatched with `store.dispatch(sendMessage(typing, activeUserId))`,Updating the Message State: Import the SEND_MESSAGE action type empty string is returned, _.keys is like Object.keys(). The only difference here is that I’m using the helper from Lodash. You can use Object.keys() if you want.
####  testing with redux and enzyme
we use it for wanted some framework which could be easily setup and start testing. i.e spend minimum time to setup the framework for my project, Ability to run tests in parallel for a huge app with lot of tests, it will be quick if the tests could run in parallel, Snapshot testing helps me in reducing the number of tests I have to write as I just create a snapshot and if anything changes in my component, I will get an error when the snapshot is generated the next time, Jest uses Jasmine for assertion, Code coverage is available right out of the box, In-built Manual mocking , the package :  jest,babel-jest,enzyme, react-addons-test-utils, react-test-renderer, redux-mock-store.
####  testing reducers
the reducer is a pure function that takes the previous state and an action, and returns the next state, it’s easy to test. It’s a function that produces no side effects; given the same input, will always return the same output; doesn’t rely on external state, t starts with boilerplate setup and writing empty tests just to outline what needs to be tested. I like to to test the initial state and then every switch/case in the reducer to see if action.payload will produce expected store.
