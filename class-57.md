###  Context API
####  Context
passing state down the component tree through a Provider/Consumer relationship, At high a level provider can make it’s state available, along with means of altering it methods,  the lower levels any component can opt-in and become a consumer and receive this.state from context, In a class style component, you can attach to context in 2 ways: Wrap your component with, and use a function to “get” the context object itself, which is this.state from the provider component, declare a connection to the context provider and then use this.context to connect to state from the context provider, functional component we can use the `useContext(`) hook to tap right in return and provides access to whatever context provider exports.
####  context api
React application, data is passed top-down (parent to child) by props, Context provides a way to share values like these between components without having to explicitly pass a prop through every level of the tree, to share data that can be considered “global” for a tree of React components, avoid passing props through intermediate elements, Context is primarily used when some data needs to be accessible by many components at different nesting levels, `React.createContext` we creates a Context object to renders a component that subscribes to Context object it will read the current context value from the closest matching Provider above it in the tree, defaultValue argument is only used when a component does not have a matching Provider above it in the tree, `Context.Provider` it allows consuming components to subscribe to context changes it accept value prop, `Class.contextType` consume the nearest current value of that Context type using this.context. You can reference this in any of the lifecycle methods including the render function, `Caveats` to determine when to re-render.

####  hooks and context example
we can communicate with our users by 3 way; low priority end of that spectrum: small notifications that show up on the screen when a user performs an action, They are not intrusive at all and appear for just a brief moment, snackbar system must easy to use and generally be very lightweight. We want to be able to place one on the screen with just a couple of lines of code, can be localized to a single centralized component. That same centralized component can be responsible for rendering them, Our provider now exposes a new function called addAlert. This function uses the local state mutator useState to properly append a new alert without destroying existing ones, The combination of these two hooks means we can have a global state and use Redux-like reducers, actions, and dispatchers to mutate that global state. 